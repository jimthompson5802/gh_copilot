Based on the requirements, the following core classes, functions, and methods will be necessary:

1. `CSVLoader`: A class responsible for loading the CSV file into a PyTorch dataset.
   - `load_dataset(file_path)`: Loads the CSV file and returns a PyTorch dataset.

2. `NeuralNetwork`: A class representing the 4-layer neural network.
   - `__init__(input_size, hidden_size, output_size)`: Initializes the neural network with the specified input, hidden, and output sizes.
   - `forward(x)`: Performs a forward pass through the neural network.
   - `train(dataset, num_epochs, learning_rate)`: Trains the neural network on the given dataset for the specified number of epochs using the specified learning rate.
   - `save_model(file_path)`: Saves the trained model to a file.

Now let's proceed with creating the necessary files and implementing the code.

**1. csv_loader.py**

```python
import torch
from torch.utils.data import Dataset
from torchvision.transforms import ToTensor
import pandas as pd


class CustomDataset(Dataset):
    def __init__(self, file_path):
        self.data = pd.read_csv(file_path)
        self.transform = ToTensor()

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        x = self.data.iloc[idx, :-1].values.astype(float)
        y = self.data.iloc[idx, -1]
        return self.transform(x), y


def load_dataset(file_path):
    dataset = CustomDataset(file_path)
    return dataset
```

**2. neural_network.py**

```python
import torch
import torch.nn as nn


class NeuralNetwork(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(NeuralNetwork, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.fc2 = nn.Linear(hidden_size, hidden_size)
        self.fc3 = nn.Linear(hidden_size, hidden_size)
        self.fc4 = nn.Linear(hidden_size, output_size)
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.relu(self.fc2(x))
        x = self.relu(self.fc3(x))
        x = self.fc4(x)
        return x


def train_model(model, dataset, num_epochs, learning_rate):
    criterion = nn.MSELoss()
    optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)

    for epoch in range(num_epochs):
        total_loss = 0
        for inputs, targets in dataset:
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {total_loss}")

    print("Training complete!")


def save_model(model, file_path):
    torch.save(model.state_dict(), file_path)
```

**3. main.py**

```python
from csv_loader import load_dataset
from neural_network import NeuralNetwork, train_model, save_model

# Load the dataset
dataset = load_dataset("data.csv")

# Define the neural network architecture
input_size = len(dataset[0][0])
hidden_size = 64
output_size = 1
model = NeuralNetwork(input_size, hidden_size, output_size)

# Train the model
num_epochs = 10
learning_rate = 0.001
train_model(model, dataset, num_epochs, learning_rate)

# Save the model
save_model(model, "model.pth")
```

In this implementation, we have three files:
- `csv_loader.py`: Contains the `CustomDataset` class responsible for loading the CSV file into a PyTorch dataset.
- `neural_network.py`: Contains the `NeuralNetwork` class representing the 4-layer neural network, as well as the `train_model` and `save_model` functions.
- `main.py`: The entry point of the program, where the dataset is loaded, the neural network is defined, trained, and the model is saved.

Please note that the code assumes that the CSV file has the columns `x1`, `x2`, `x3`, and `y`. The target variable `y` is assumed to be a numerical value.